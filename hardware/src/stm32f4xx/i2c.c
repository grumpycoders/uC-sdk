#include "i2c.h"

#include <hardware.h>

#include <stm32f4xx_i2c.h>

#include <gpio.h>

static I2C_TypeDef * const i2cs[] = { (void *) 0, I2C1, I2C2, I2C3 };

void i2c_config(i2c_port_t i2c_port, uint32_t speed)
{
    i2c_t i2c = i2c_port.i2c;
    pin_t scl = i2c_port.scl;
    pin_t sda = i2c_port.sda;

    I2C_TypeDef *id = i2cs[i2c];

    RCC->APB1ENR |= RCC_APB1Periph_I2C1 << (i2c - 1);

    gpio_config_alternate(sda, pin_dir_read, pull_down, 4);
    gpio_config_alternate(scl, pin_dir_read, pull_down, 4);

    //Init I2C
    I2C_InitTypeDef i2cdef;
    i2cdef.I2C_Mode = I2C_Mode_I2C;
    i2cdef.I2C_DutyCycle = I2C_DutyCycle_2;
    i2cdef.I2C_OwnAddress1 = 0x00;
    i2cdef.I2C_Ack = I2C_Ack_Enable;
    i2cdef.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    i2cdef.I2C_ClockSpeed = speed;

    I2C_Init(id, &i2cdef);
    I2C_Cmd(id, ENABLE);

/*
#if (defined(I2C1_USE_DMA_TX) || defined(I2C1_USE_DMA_RX) || defined(I2C2_USE_DMA_TX) || defined(I2C2_USE_DMA_RX))
 	i2c_dma_init(id);
#endif */
}
/*
void i2c_dma_init(uint8_t id)
{

}
*/
void i2c_start_read(i2c_t i2c, uint8_t destination)
{
    I2C_TypeDef * id = i2cs[i2c];

    I2C_GenerateSTART(id, ENABLE);
    while (!I2C_CheckEvent(id, I2C_EVENT_MASTER_MODE_SELECT));
    I2C_Send7bitAddress(id, destination, I2C_Direction_Receiver);
    while (!I2C_CheckEvent(id, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
}

void i2c_start_write(i2c_t i2c, uint8_t destination)
{
    I2C_TypeDef * id = i2cs[i2c];

    I2C_GenerateSTART(id, ENABLE);
    while (!I2C_CheckEvent(id, I2C_EVENT_MASTER_MODE_SELECT));
    I2C_Send7bitAddress(id, destination, I2C_Direction_Transmitter);
    while (!I2C_CheckEvent(id, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
}

void i2c_stop(i2c_t i2c)
{
    I2C_GenerateSTOP(i2cs[i2c], ENABLE);
}


void i2c_read_polling(i2c_t i2c, uint8_t *value, uint8_t nb)
{
    I2C_TypeDef * id = i2cs[i2c];

    while (nb--){
        if (nb == 0)
            I2C_AcknowledgeConfig(id, DISABLE);

        while (!I2C_CheckEvent(id, I2C_EVENT_MASTER_BYTE_RECEIVED));
        *value++ = I2C_ReceiveData(id);
    }

    I2C_AcknowledgeConfig(id, ENABLE);
}

void i2c_write_polling(i2c_t i2c, uint8_t *value, uint8_t nb)
{
    I2C_TypeDef * id = i2cs[i2c];

    while (nb--){
        I2C_SendData(id, *value++);
        while(!I2C_CheckEvent(id, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
    }
}


#if 0
/**
 ===============================================================================
               I2C Slave Events (Events grouped in order of communication)
 ===============================================================================
 */

/**
  * @brief  Communication start events
  *
  * Wait on one of these events at the start of the communication. It means that
  * the I2C peripheral detected a Start condition on the bus (generated by master
  * device) followed by the peripheral address. The peripheral generates an ACK
  * condition on the bus (if the acknowledge feature is enabled through function
  * I2C_AcknowledgeConfig()) and the events listed above are set :
  *
  * 1) In normal case (only one address managed by the slave), when the address
  *   sent by the master matches the own address of the peripheral (configured by
  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set
  *   (where XXX could be TRANSMITTER or RECEIVER).
  *
  * 2) In case the address sent by the master matches the second address of the
  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled
  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED
  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
  *
  * 3) In case the address sent by the master is General Call (address 0x00) and
  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd())
  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.
  *
  */

/* --EV1  (all the events below are variants of EV1) */
/* 1) Case of One Single Address managed by the slave */
#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */

/* 2) Case of Dual address managed by the slave */
#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */

/* 3) Case of General Call enabled for the slave */
#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */

/**
  * @brief  Communication events
  *
  * Wait on one of these events when EV1 has already been checked and:
  *
  * - Slave RECEIVER mode:
  *     - EV2: When the application is expecting a data byte to be received.
  *     - EV4: When the application is expecting the end of the communication: master
  *       sends a stop condition and data transmission is stopped.
  *
  * - Slave Transmitter mode:
  *    - EV3: When a byte has been transmitted by the slave and the application is expecting
  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be
  *      used when the user software doesn't guarantee the EV3 is managed before the
  *      current byte end of transfer.
  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission
  *      shall end (before sending the STOP condition). In this case slave has to stop sending
  *      data bytes and expect a Stop condition on the bus.
  *
  *  @note In case the  user software does not guarantee that the event EV2 is
  *        managed before the current byte end of transfer, then user may check on EV2
  *        and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
  *        In this case the communication may be slower.
  *
  */

/* Slave RECEIVER mode --------------------------*/
/* --EV2 */
#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
/* --EV4  */
#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */

/* Slave TRANSMITTER mode -----------------------*/
/* --EV3 */
#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
/* --EV3_2 */
#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
#endif

void I2C1_EV_IRQHandler()
{
  #if 0
  switch (I2C_GetLastEvent(I2C1))
  {
    // Check on EV1  - Slave receiver received
    case I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED:
        I2C_ITConfig(I2C1, I2C_IT_BUF, ENABLE);
        break;
    // Check on EV1 - Slave transmitter received address
    case I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED:
        I2C_SendData(I2C1, buffer[i++]);
        I2C_ITConfig(I2C1, I2C_IT_BUF, ENABLE);
        break;

    case I2C_EVENT_SLAVE_BYTE_RECEIVED:
        iI2C_ReceiveData(I2C1);

    // Check on EV3
    case I2C_EVENT_SLAVE_BYTE_TRANSMITTING:
        break;
    case I2C_EVENT_SLAVE_BYTE_TRANSMITTED:

      if (i < nb)
        I2C_SendData(I2C1, buffer[i++]);
      else
          I2C_ClearFlag(I2C1, I2C_FLAG_AF);
      break;

    case I2C_EVENT_SLAVE_STOP_DETECTED:
        I2C_GetFlagStatus(I2C1, I2C_FLAG_STOPF);
        I2C_Cmd(I2C1, ENABLE);
        break;
    default:
      break;
  }
  #endif
}

void I2C1_ER_IRQHandler()
{
}

void I2C2_EV_IRQHandler()
{
}

void I2C2_ER_IRQHandler()
{
}


/*
void i2c_read_dma(i2c_t i2c, uint8_t *value, uint8_t nb)
{

}

void i2c_write_dma(i2c_t i2c, uint8_t *value, uint8_t nb)
{

}*/

